Django Installation

Open Command Prompt
//install django
pip install django

------------------------

Start new Django project

//check the list of available subcommands
django-admin

Navigate to the desired location in the file directory

//start new project
django-admin startproject mysite

------------------------

Django considers all projects to be collection of apps

Our project directory is called mysite and mysite is also the primary app

Role of the primary app is to link other apps

Besides managing settings and urls not much is done there

------------------------

Add an app to our project

We use manage.py helper python script to start new app

Navigate to the directory where manage.py is located

//start new app
python manage.py startapp main

A new directory by the name of main is created at the location

------------------------

Project Structure

mysite
    -main (directory, your new app)
    -mysite (directory, this is your "primary" app)
    -manage.py (helper python script)

Run server using manage.py

Open another Command Prompt window

//run the server
python manage.py runserver

We will see something like

---------------------------------------------------------------------
Performing system checks...

System check identified no issues (0 silenced).

You have 15 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.
January 10, 2019 - 18:50:09
Django version 2.1.5, using settings 'mysite.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CTRL-BREAK.
---------------------------------------------------------------------

Our development server is running at http://127.0.0.1:8000

Head to that address in web browser

Keep the server running in the separate command prompt window

------------------------

Django uses Model View Controller (MVC) paradigm

Model: database abstraction, which contain objects that are mapped to database

View: render things to a user

Controller: maps URLs to views

A user will visit a URL, controller (urls.py) points to a specific view (views.py). That view then interface with models.

------------------------

Let's display some simple text at the homepage.

To do this, we don't need a model. We only need the view and the controller.

Tell Django that homepage should return some view

Django begins in "primary" app when looking for URLs. So first, let's go to: mysite/mysite/urls.py 

We need to point URL to a view.

urls.py file inside "primary" app is usually just going to point to other apps. We just point to that app's urls.py file as

---------------------------------------------------------------------
from django.contrib import admin
from django.urls import path, include    # import "include" from django.urls

urlpatterns = [
    path("", include('main.urls')),    # the path is empty (the homepage), look inside the main app at its urls.py file to see if that file (the controller) points to a view
    path('admin/', admin.site.urls),
]
---------------------------------------------------------------------

Add urls.py in mysite/main app

mysite/main/urls.py

---------------------------------------------------------------------
from django.urls import path
from . import views


app_name = 'main'  # here for namespacing of urls. not required at the moment. very useful when we want to dynamically reference URLs

urlpatterns = [
    path("", views.homepage, name="homepage"),
]
---------------------------------------------------------------------

We've got the controller all set.

When someone visits the homepage, Django looks first at the mysite/mysite/urls.py, it points to mysite/main/urls.py, which then points to views.homepage (a function called homepage inside of views.py)

mysite/main/views.py

---------------------------------------------------------------------
from django.shortcuts import render
from django.http import HttpResponse    # these views render some HTML template and pass some variables, but we're just going return a straight HTTP response.

# Create your views here.
def homepage(request):    # We told urls.py to look for a homepage function, so let's define that
    return HttpResponse("pythonprogramming.net homepage! Wow so #amaze.")    # we pass request to the view
---------------------------------------------------------------------

Refresh the browser

At the homepage, you should see "pythonprogramming.net homepage! Wow so #amaze."

------------------------

Introduction to the concept of Models, which is where the majority of the value of Django comes from. Open models.py from main

mysite/main/models.py

---------------------------------------------------------------------
from django.db import models

# Create your models here.
class Tutorial(models.Model):    # All models will inherit from models.Model
    tutorial_title = models.CharField(max_length=200)
    tutorial_content = models.TextField()
    tutorial_published = models.DateTimeField('date published')

    def __str__(self):
        return self.tutorial_title
---------------------------------------------------------------------

We started with the Tutorial model

tutorial_title, tutorial_cotent and tutorial_published are some attributes of Tutorial model

With Django more fields can easily be added to the database later

Each model is a unique class within app's models.py file

We expect our title to be fairly short, so we define this as a CharField

We use the CharField for something that does have a limit to the size, and a TextField when we don't have a limit

These fields correspond to the format of our data in the actual database

We override the the __str__ special method to make it a bit more readable when it's being displayed in string form

------------------------

Any time there is a change in models or either there is a new model, we need to do a migration

First, we run makemigrations, then we run migrate

Migrations only apply to apps that we've told Django that we want "installed

Go into mysite/mysite/settings.py and add 'main.apps.MainConfig', to INSTALLED_APPS

mysite/mysite/settings.py

---------------------------------------------------------------------
INSTALLED_APPS = [
    'main.apps.MainConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
---------------------------------------------------------------------

open mysite/main/apps.py to check

---------------------------------------------------------------------
from django.apps import AppConfig


class MainConfig(AppConfig):
    name = 'main'
---------------------------------------------------------------------

//use manage.py script and run makemigrations
python manage.py makemigrations

It just builds the code required for the migration, it doesn't actually apply them

We can see all migrations by going to the migrations directory of an app

mysite/main/migrations/0001_initial.py

---------------------------------------------------------------------
# Generated by Django 2.1.5 on 2019-01-11 01:35

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Tutorial',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('tutorial_title', models.CharField(max_length=200)),
                ('tutorial_content', models.TextField()),
                ('tutorial_published', models.DateTimeField(verbose_name='date published')),
            ],
        ),
    ]
---------------------------------------------------------------------

//See the exact SQL that will be run
python manage.py sqlmigrate main 0001

---------------------------------------------------------------------
BEGIN;
--
-- Create model Tutorial
--
CREATE TABLE "main_tutorial" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "tutorial_title" varchar(200) NOT NULL, "tutorial_content" text NOT NULL, "tutorial_published" datetime NOT NULL);
COMMIT;
---------------------------------------------------------------------

//let's actually migrate then
python manage.py migrate

---------------------------------------------------------------------
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, main, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying main.0001_initial... OK
  Applying sessions.0001_initial... OK
---------------------------------------------------------------------

//Add a tutorial in the database. One quick way to do this is through the shell
python manage.py shell

----------------------------------------------------------------------
Python 3.7.2 (tags/v3.7.2:9a3ffc0492, Dec 23 2018, 23:09:28) [MSC v.1916 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
----------------------------------------------------------------------

This is  quick way to interact with our website without the need to write up some view and controller just to test something

Let's import our Tutorial model

---------------------------------------------------------------------
>>> from main.models import Tutorial
>>> Tutorial.objects.all()
<QuerySet []>
---------------------------------------------------------------------

We can make a new Tutorial object from here

Our attributes were tutorial_title, tutorial_content and tutorial_published. Two of these are just strings, one is a date.

Let's import timezone

---------------------------------------------------------------------
>>> from django.utils import timezone
---------------------------------------------------------------------

Make a new Tutorial object

---------------------------------------------------------------------
>>> new_tutorial = Tutorial(tutorial_title="To be", tutorial_content="or not to be. That is the question.", tutorial_published=timezone.now())
---------------------------------------------------------------------

Commit this object to our database

---------------------------------------------------------------------
>>> new_tutorial.save()
---------------------------------------------------------------------

we can do

---------------------------------------------------------------------
>>> Tutorial.objects.all()
<QuerySet []>
---------------------------------------------------------------------

We can iterate over QuerySet like

---------------------------------------------------------------------
>>> for t in Tutorial.objects.all():
...     print(t.tutorial_title)
...
To be
---------------------------------------------------------------------

